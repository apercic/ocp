- inheritance: metode se kličejo glede na tip new() objecta, fieldi(in statične metode!) se kličejjo glede na trenutno referenco
- private>default>protected>public
- pr overridanju v childu more bit manj restrictive acces modifier
- An overriding method (i.e. a sub class's method) is allowed to return a sub-type of the type returned by the overridden method (i.e. super class's method).
- int k = 1; k += 3 + ++k; ---> k=6 rezultat
- Any field in an interface is implicitly public, static, and final, whether these keywords are specified or not.
- final vedno inicializirane(+vsakmu konstruktorju)
- subclass pr override more vedno met širši dostop
- pr inicializaciji najprej statične stvari, potem ostalo
- static methods can't be overriden
- var nemoreš pr: fields, method params, method return types
- subclasses of ArrayList: AttributeList, RoleList, RoleUnresolvedList (ArrayList is a subclass of AbstractList)
- new StringBuilder("world").insert(0, "hello ").toString() = hello world - insert takes argument offset
- you can say int a; in main method - just can't use it before initialized
- widening is preferred over boxing/unboxing
- Only methods of an interface can be private. private/protected fields are not allowed.
- tud če maš new Child() in kličeš Parent p = new Child(); nad p kličeš metodo - kliče jo iz Child objekta
  ampak more zarad reference ta metoda tud obstajat v parentu... lahk castaš v interface ali parent
- precedence: ++, +, ==, =
- constructor cant be static
- An interface can have a static method but the method must have a body in that case. Can also have private methods.
 All interface methods have to be either public or private
- Queue - add dodaja normalno kt v vrsto, push pa ravno obratno se vrine na začetek
- constructors and initializers are not invoked during deserialization
- Arrays.compare() -1 if first less/shorter than second, 0 equals, 1 if first more/longer than second
- 'var' is not allowed in a compound declaration
- when calling constructor/method with a reference in lambda - can't pass paramether - this is a reference not an accual invocation
ls.stream()
.map(x->MyProcessor::new(x))  //not legal .map(MyProccesor::new) is ok
.forEach(MyProcessor::process);

- var es = Executors.newCachedThreadPool();
  es.submit(Runnable/Callable)
  
-  Future<?> rf = es.submit(r); is ok, but if you specify the return type of Runnable it's not
- Path.subpath(int beginIndex, int endIndex)
index 0, root not considered as start, end index excluded, no starting or ending /

- PreparedStatement allows several additional SQL types such as BLOB and CLOB.
PreparedStatement offers better performance when the same query is to be run multiple times with different parameter values.

- ExecutorService.submit() - can return - excepts Runnable&Callable
  Executor.execute() . cant return - excepts just Runnable
  
- findAny() returns Optional, suquential() is made non-deterministic - use findFirst() if you want first result
- default method in interface is always an instance method - cant be static
- sql stmt.executeUpdate(updateString); is auto-commit mode
- if ambigous interface methods from implemented - must provide own to avoid ambiguity
- interface fields are public, static, final = cant be changed outside of interface
- ps.setNull(3, Types.INTEGER);
  ps.setNull(4, Types.VARCHAR);
  
- The List.subList method returns a view backed by the original list. It doesn't change the existing list
- Remember that @SuppressWarnings annotation requires at least one string argument
- functional interface = one abstract method
-  A switch condition cannot accept float, long, double, or boolean

- var raf = new RandomAccessFile("c:\\temp\\test.txt", "rwd");
  raf.writeChars("hello");
  raf.close();
If test.txt not exist - try to create. pointer at first position = writes at the begining of the file  
 - Any exception that is thrown while closing a resource is added to the list of suppressed exceptions

- jdbc index starts with 1
- IntStrem has paralel() but no parallelStream()
- this( ... ) can only be called in a constructor and that too as a first statement
- method overloading has no relation with return-type

- To write at the end of the file
RandomAccessFile raf = new RandomAccessFile("file.txt", "rw");
raf.seek( raf.length() );
raf.writeChars("FINAL TEXT");

- provides clause must have a "with" part also that specifies that class that implements the service
- DateTimeFormatter.ofPattern("eeee d'st day of' MMMM yyyy") = Saturday 1st day of January 2000
- Locale.IT means, the language is "it" and country is "IT"
- nonmodular jars should be put on classpath instead of module-path
- 



















MODULES:
-d: Set the destination directory for class files
--module-path(-p): To je tk k classpath(dependencies)
--module(-m)
--describe-module(-d)
-summay(-s)

javac --module-path mods -d feeding feeding/zoo/animal/feeding/*.java feeding/module-info.java
java --module-path feeding --module zoo.animal.feeding/zoo.animal.feeding.Task
jar -cvf mods/zoo.animal.feeding.jar -C feeding/ .
(jar -cvf dd.jar -C feeding/ .)
java -p mods --describe-module zoo.animal.feeding
java --list-modules (info, ne zažene programa)
java --show-module-resolution -p feeding -m zoo.animal.feeding/zoo.animal.feeding.Task(info, zažene)
jar --file mods/zoo.animal.feeding.jar --describe-module
jdeps -summary mods/zoo.animal.feeding.jar(lists dependencies)


Running module:
module name/full class
pr "java" command damo pr module-path tisto kjer smo pr "javac" compajlal kodo(feeding v tem primeru)
