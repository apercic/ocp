EXCEPTIONS:
- In Java, all exceptions that inherit Exception but not RuntimeException are considered checked exceptions(checked need to be handled)
- unchecked exceptions include any class that inherits RuntimeException or Error. An Error is fatal, and it is considered a poor practice to catch it.
- FileNotFoundException and NotSerializableException both inherit from IOException (checked exceptions)
-try‐with‐resources statements require resources that implement the AutoCloseable interface

CONCURRENCY:
- java.lang.Runnable is a functional interface that takes no arguments and returns no data
ex. Runnable sloth = () -> System.out.println("Hello World");
- Even though Runnable is a functional interface, many classes implement it directly:

public class CalculateAverage implements Runnable {
  public void run() {}
}

- Executing a task with Thread is a two-step process. Define the Thread with the corresponding task to be done, start task with Thread.start() method.
- Defining a task that a Thread instance will execute: (implementing Runnable is the correct-er method - Inherit only if you want to override some behavior - not the case here)
public class PrintData implements Runnable {
  @Override public void run() { // Overrides method in Runnable
    for(int i = 0; i < 3; i++)
      System.out.println("Printing record: "+i);
    }
public static void main(String[] args) {
  (new Thread(new PrintData())).start();


public class ReadInventoryThread extends Thread {
  @Override public void run() { // Overrides method in Thread
    System.out.println("Printing zoo inventory");
  }
public static void main(String[] args) {
  (new ReadInventoryThread()).start();
- Calling run() on a Thread or a Runnable does not actually start a new thread. (just executes code in same thread)

- java.util.concurrent.atomic package Atomic classes - solving the race condition
- AtomicBoolean, AtomicInteger, AtomicLong (new AtomicInteger(0); get(), set(), getAndSet(), getAndIncrement(), decrementAndGet()..)

- SheepManager manager = new SheepManager();
synchronized(manager) {
// Work to be completed by one thread at a time - one thread acquires the lock
} 
-To synchronize access across multiple threads, each thread must have access to
the same Object. For example, synchronizing on different objects would not actually order the results.
- You must synchronize the execution of threads not their creation
- synchronized blocks allow only one thread to enter

- Lock interface - like synchronize just better, can only lock on object that implements the Lock interface
Lock lock = new ReentrantLock();
  try {
    lock.lock();
  // Protected code
  } finally {
    lock.unlock();
  }
  
- It is critical that you release a lock the same number of times it is acquired. For calls with tryLock(), you
need to call unlock() only if the method returned true. 
- 
  
